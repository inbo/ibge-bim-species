---
title: "Set parent IDs based on GBIF Taxonomy Backbone"
author:
  - Damiano Oldoni
  - Lien Reyserhove
  - Peter Desmet
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    theme: yeti
    df_print: paged
knit: (function(input_file, encoding) { rmarkdown::render(input_file, encoding = encoding, output_file = paste0("../docs/",sub(".Rmd", ".html", basename(input_file))))})
---

# Setup

## Load libraries

```{r load_libs}
library(tidyverse)  # To do data science
library(tidylog)    # To provide feedback on dplyr functions
library(here)       # To work with paths
library(rgbif)      # To work with GBIF 
```

# Read taxa

Read taxa after match with GBIF Backbone from `./data/interim/taxa_final_match_gbif.tsv`:

```{r read_taxa_gbif_after_match}
taxa_match_gbif <- read_tsv(
  here("data", "interim", "taxa_final_match_gbif.tsv"),
  col_types = cols(
    .default = col_character(),
    id = col_double(),
    n_occs = col_double(),
    parentid = col_double(),
    media = col_logical(),
    speciesbeparentid = col_double(),
    bruenvi_created = col_date(format = "%Y-%m-%d"),
    bruenvi_modified = col_date(format = "%Y-%m-%d"),
    kingdom_id = col_double(),
    gbif_usageKey = col_double(),
    gbif_confidence = col_double(),
    gbif_kingdomKey = col_double(),
    gbif_phylumKey = col_double(),
    gbif_classKey = col_double(),
    gbif_orderKey = col_double(),
    gbif_familyKey = col_double(),
    gbif_genusKey = col_double(),
    gbif_synonym = col_logical(),
    gbif_acceptedUsageKey = col_double(),
    gbif_speciesKey = col_double())
)
```

Number of taxa matched with GBIF:

```{r taxa_match_gbif_count_matchType}
taxa_match_gbif %>%
  group_by(gbif_matchType) %>%
  count()
```

If we limit to used taxa:

```{r used_taxa_match_gbif_count_matchType}
taxa_match_gbif %>%
  filter(used == TRUE) %>%
  group_by(gbif_matchType) %>%
  count()
```

# Set parent ID based on GBIF match

## Get GBIF parent key

The match to GBIF Backbone doesn't return a field with the parent key. However, we can retrieve it easily by using another rgbif function: `name_usage`. We add this information in column `gbif_parentKey`. We apply it at the moment only to used taxa. **Note: this step can take long**.

```{r set_gbif_parentKey, cache=TRUE}
pb <- progress_estimated(nrow(taxa_match_gbif))

# function to get parent key - wrapper around name_usage
get_gbif_parent_key <- function(gbif_usageKey) {
  pb$tick()$print()
  parent_key <- NA_real_
  if (!is.na(gbif_usageKey)) {
    data <- name_usage(gbif_usageKey, 
             return = "data")
    if ("parentKey" %in% names(data)) {
      parent_key <- 
        data %>% 
        pull(parentKey)
    }
  }
  return(parent_key)
}

# apply function to all taxa
taxa_gbif_parent_key <- 
  taxa_match_gbif %>%
  mutate(gbif_parentKey = map_dbl(gbif_usageKey,
                                   get_gbif_parent_key))
```

## Check completeness GBIF parent keys

We check the completeness of the taxonomic tree as provided by GBIF. Number of taxa whose GBIF parent keys are (not) present in taxa:

```{r parent_in_db}
taxa_gbif_parent_key %>% 
  filter(!is.na(gbif_usageKey)) %>%
  group_by(gbif_parentKey %in% (taxa_gbif_parent_key$gbif_usageKey)) %>%
  summarize(n_taxa = n()) %>%
  rename(parent_in_db = "gbif_parentKey %in% (taxa_gbif_parent_key$gbif_usageKey)")
```

More detailed summary about taxa with no parents:

```{r missing_parent_key_status_rank}
taxa_gbif_parent_key %>% 
  filter(!is.na(gbif_usageKey)) %>%
  group_by(gbif_parentKey %in% taxa_gbif_parent_key$gbif_usageKey,
           gbif_rank,
           gbif_status,
           used) %>%
  rename(parent_in_db = "gbif_parentKey %in% taxa_gbif_parent_key$gbif_usageKey") %>%
  filter(parent_in_db == FALSE) %>%
  count() %>%
  arrange(desc(n)) %>%
  ungroup() %>%
  select(-parent_in_db)
```

As some taxa share same parent keys, we list here below the missing parent keys, ordered by the number of taxa pointing to them:

```{r not_present_parent_keys}
taxa_gbif_parent_key %>%
  filter(!gbif_parentKey %in% taxa_gbif_parent_key$gbif_usageKey) %>%
  group_by(gbif_parentKey) %>%
  count() %>%
  arrange(desc(n))
```

This means, for example, that just adding [Coprinopsis Beeli (GBIF key 6005961)](https://www.gbif.org/species/6005961) to taxonomic table would provide a parent key to 77 taxa.

Number of unique GBIF parent keys we need to add:

```{r n_distinct_parentkeys_to_add}
taxa_gbif_parent_key %>%
  filter(!gbif_parentKey %in% taxa_gbif_parent_key$gbif_usageKey) %>%
  distinct(gbif_parentKey) %>%
  nrow()
```

## Add missing taxa

We add now the missing taxa pointed by parent keys in order to complete the taxonomic tree. 

First, we retrieve such taxa from GBIF Backbone:

```{r get_missing_taxa_pointed_by_parentKey, cache=TRUE}
# select GBIF fields: add authorship
gbif_fields <- 
  taxa_gbif_parent_key %>% 
  select(starts_with("gbif")) %>%
  names()
gbif_fields <- c(gbif_fields, "gbif_authorship")

get_gbif_taxonomic_info <- function(key) {
  name_usage(key, return = "data")
}

missing_gbif_keys <- 
  taxa_gbif_parent_key %>%
  filter(!gbif_parentKey %in% taxa_gbif_parent_key$gbif_usageKey) %>%
  distinct(gbif_parentKey) %>%
  pull()

gbif_info_missing_taxa <- map_dfr(missing_gbif_keys, get_gbif_taxonomic_info)
gbif_info_missing_taxa <- 
  gbif_info_missing_taxa %>% 
  rename(usageKey = key)

names(gbif_info_missing_taxa) <- paste0("gbif_", 
                                          names(gbif_info_missing_taxa))
gbif_info_missing_taxa <- 
  gbif_info_missing_taxa %>%
  select(one_of(gbif_fields))
```

To add them to other taxa we need to set `acceptedname` and `scientificnameauthorship` equal to `gbif_canonicalName` and `gbif_authorship` respectively. We can also fill the taxonomic rank in  `taxonranken`:

```{r set_acceptedname_authorship}
gbif_info_missing_taxa <-
  gbif_info_missing_taxa %>%
  mutate(acceptedname = case_when(
    is.na(gbif_canonicalName) ~ gbif_scientificName, # 9659865: genus Festuca x Lolium
    TRUE ~ gbif_canonicalName)) %>%
  rename(scientificnameauthorship = gbif_authorship) %>%
  mutate(taxonranken = tolower(gbif_rank))
```

We also add column `id` with unique identifier. For easier identification, we assign them numbers higher than 100000 (maximum `id` of taxa in `biodiv.taxon` table: 51833). **Note: while inserting new taxa to a database, the id will be created authomatically. Column `id` is therefore not needed, but it is handy as it acts as a unique identifier.**

```{r set-id}
gbif_info_missing_taxa <-
  gbif_info_missing_taxa %>%
  mutate(id = seq(1:nrow(gbif_info_missing_taxa))+100000) %>%
  select(id, acceptedname, scientificnameauthorship, taxonranken, everything())
```

These taxa are now ready to be added to the other taxa. We flag thm by adding column `added_from_gbif` with value `TRUE`, while the other ones get value `FALSE`:

```{r add_gbif_info_missing_taxa_to_taxa_gbif_parent_key}
taxa_gbif_parent_key_complete <-
  taxa_gbif_parent_key %>%
  bind_rows(gbif_info_missing_taxa)
taxa_gbif_parent_key_complete <-
  taxa_gbif_parent_key_complete %>%
  mutate(added_from_gbif = ifelse(id > 100000, TRUE, FALSE))
```

## Assign parent ID based on GBIF parent keys

We map now all GBIF parent keys to internal parent IDs:

```{r assign_parent_id, cache=TRUE}
find_parentid <- function(parent_key) {
  suppressMessages(
    parent_id <- 
      taxa_gbif_parent_key_complete %>%
      filter(gbif_usageKey == parent_key)
  )
  if (nrow(parent_id) > 1) {
    # remove duplicates based on number of occurences and id number
    if (any(!is.na(parent_id$n_occs))) {
      suppressMessages(
        parent_id <- 
          parent_id %>%
          filter(n_occs == max(n_occs, na.rm =  TRUE)) %>%
          # if same n_occs, choose based on id number
          filter(id == min(id))
      )
    } else {
      # remove duplicates based on id number
      suppressMessages(
        parent_id <- 
          parent_id %>%
          filter(id == min(id))
      )
    }
  }
  if (nrow(parent_id) > 0) {
    parent_id <- 
      parent_id %>%
      pull(id)
  } else {
    NA_real_
  }
}

gbif_parent_keys <- 
  taxa_gbif_parent_key_complete %>%
  filter(!is.na(gbif_parentKey)) %>%
  distinct(gbif_parentKey)

gbif_parent_keys <- 
  gbif_parent_keys %>%
  mutate(parentid_corrected = map_dbl(gbif_parentKey, find_parentid))
```

We can now add the new parent IDs to data.frame. In order to keep track of changes and compare the new parent IDs with the old ones, we add these values in new column called `parentid_corrected`:

```{r add_new_parentids_to_df}
taxa_gbif_parent_key_complete <- 
  taxa_gbif_parent_key_complete %>%
  left_join(gbif_parent_keys,
            by = "gbif_parentKey")
```

# Save final version of taxa

We save the taxa with corrected parent IDs:

```{r save_taxa_parentid_corrected}
write_tsv(taxa_gbif_parent_key_complete,
          here("data", "processed", "taxa_parentid_corrected.tsv"),
          na = "")
```

We also save the new version of table `biodiv.taxon`. This file is saved following the technical specifications provided by BIM's IT expert, who is in charge to apply changes to BIM database. These specifications are:

- file contains only the same columns as in  `biodiv.taxon`
- encoding UTF-8
- pipe separated text file

Columns of `biodiv.taxon` table:

```{r columns_biodiv_taxon, results="hide"}
columns_biodiv_taxon <- 
  read_tsv(here("data", "raw", "taxa.tsv"), n_max = 1) %>%
  names()
```

Select columns to include:

```{r save_new_biodiv_taxon}
new_biodiv_taxon <- 
  taxa_gbif_parent_key_complete %>%
  mutate(parentid = parentid_corrected) %>%
  select(one_of(columns_biodiv_taxon))
```

Save taxa as UTF-8 (default) using pipe `|` as delimiter:

```{r save_new_biodiv_taxon}
write_delim(new_biodiv_taxon, 
            path = here("data", "processed", "biodiv.taxon.txt"), 
            na = "",
            delim = "|")
```
