---
title: "Match taxa with GBIF Taxonomy Backbone"
author:
  - Damiano Oldoni
  - Lien Reyserhove
  - Peter Desmet
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    theme: yeti
    df_print: paged
knit: (function(input_file, encoding) { rmarkdown::render(input_file, encoding = encoding, output_file = paste0("../docs/",sub(".Rmd", ".html", basename(input_file))))})
---

# Setup

## Load libraries

```{r load_libs}
library(odbc)       # To work with database
library(tidyverse)  # To do data science
library(here)       # To work with paths
library(inborutils) # To match taxa (rgbif called in background)
```

## Load access informations

Retrieve access informations from configuration file:

```{r get_access_infos}
ibge_bim <- config::get("ibge_bim")
```

# Read taxa

Read taxa from `./data/interim/taxa.tsv`:

```{r read_taxa_from_tsv_file}
taxa <- read_tsv(here("data", "interim", "taxa.tsv"),
                 col_types = cols(
                   .default = col_character(),
                   id = col_double(),
                   parentid = col_double(),
                   media = col_logical(),
                   speciesbeparentid = col_double(),
                   bruenvi_created = col_date(format = "%Y-%m-%d"),
                   bruenvi_created = col_date(format = "%Y-%m-%d"),
                   kingdom_id = col_double()
                   )
)
```

# Match taxa to GBIF Taxonomy Backbone

## Match by `acceptedname` + `scientificnameauthorship`

We try to match by using `acceptedname` + `scientificnameauthorship`.
First, we prepare `taxa` for matching. In this step:

1. We create a new column, `name_for_gbif`, where we paste `acceptedname` and `scientificnameauthorship`, if present.
2. Recode the taxon ranks from `taxonranken` in a new column, `rank_for_gbif`, containing the correct GBIF terms

```{r prepare_taxa_for_matching_backbone}
taxa <-
  taxa %>%
  mutate(name_for_gbif = if_else(
    !is.na(scientificnameauthorship),
    paste(acceptedname, scientificnameauthorship),
    acceptedname
  )) %>%
  mutate(rank_for_gbif = recode(taxonranken,
    "forma" = "form",
    "subforma" = "subform",
    "informal group" = NA_character_
  ))
```

We match the names in `name_for_gbif` with GBIF Backbone. We also use the columns containing kingdom information, `bim_kingdom`, and rank, `rank_for_gbif`, and we require a strict match, `strict = TRUE` to avoid fuzzy match with higher classification. **Note: This step takes long**:

```{r get_name_gbif}
taxa_gbif <-
  taxa %>%
  gbif_species_name_match(name = "name_for_gbif",
                          kingdom = "bim_kingdom", 
                          rank = "rank_for_gbif",
                          strict = TRUE)
```

Some columns containing GBIF data have been added. Preview:

```{r overview}
taxa_gbif %>%
  head()
```

The column `matchType` informs us whether the match has been successful, `matchType` = `EXACT`, doubtful, `matchType` = `FUZZY`, or failed, `matchType` = `NONE`. The column  `confidence` is also informative. Number of taxa for each value of `matchType`:

```{r overview_n_match}
taxa_gbif %>%
  group_by(matchType) %>%
  count()
```

We create a new data.frame, `taxa_no_exact_match`, for taxa without exact match:

```{r taxa_no_exact_match}
taxa_no_exact_match <-
  taxa_gbif %>%
  filter(matchType != "EXACT") %>%
  arrange(id)
```

Preview (only relevant columns shown):

```{r not_matched_taxa}
taxa_no_exact_match %>%
  select(-c(speciesbeid, colid, vernacularnamefr, 
            vernacularnamenl, parentid, distributionstatuscode, 
            media, speciesbeparentid, bruenvi_created, bruenvi_author,
            bruenvi_modified, kingdom_id)) %>%
  head()
```

### Match by `acceptedname` only

Some of the taxa are not matched due to deviating author spellings, e.g.

```{r example_no_match_due_to_author_spelling_deviation}
taxa_no_exact_match %>%
  filter(name_for_gbif == "Neosartorya fischeri var. glabra (Fennell & Raper) Malloch & Cain")
```

while in GBIF Backbone:

```{r}
rgbif::name_backbone(name = "`Neosartorya fischeri var. glabra Fennell & Raper, 1973`") %>% as_tibble()
```

Matching without authors can improve matching:

```{r match_acceptedname_only}
taxa_gbif_acceptedname <-
  taxa_no_exact_match %>%
  select(names(taxa)) %>%
  gbif_species_name_match(name = "acceptedname",
                          kingdom = "bim_kingdom", 
                          rank = "rank_for_gbif",
                          strict = TRUE)
```

Overview match:

```{r summarize_new_match}
taxa_gbif_acceptedname %>%
  group_by(matchType) %>%
  count()
```

As some of the matches might be wrong, we update `matchType` to `EXACT_WITHOUT_AUTHOR`, `FUZZY_WITHOUT_AUTHOR`:

```{r flag_matchType}
taxa_gbif_acceptedname <-
  taxa_gbif_acceptedname %>%
  mutate(matchType = case_when(
    matchType == "EXACT" ~ "EXACT_WITHOUT_AUTHOR",
    matchType == "FUZZY" ~ "FUZZY_WITHOUT_AUTHOR",
    TRUE ~ matchType)
)
```

Include the results of this second match attempt to `taxa_gbif`:

```{r join_taxa_gbif_acceptedname}
taxa_gbif <-
  taxa_gbif %>%
  anti_join(taxa_gbif_acceptedname,
            by = "id") %>%
  bind_rows(taxa_gbif_acceptedname) %>%
  arrange(id)
```

Overview:

```{r overview_matchType}
taxa_gbif %>%
  group_by(matchType) %>%
  count()
```

### Match without kingdom

Due to errors in parent IDs, some taxa are not matched because they are linked to the wrong kingdom. Examples, the phylum `Xanthophyta`:

```{r example_Xanthophyta}
taxa_gbif %>% filter(acceptedname == "Xanthophyta")
```

Its `bim_kingdom` is based on parentid `45975`, which refers to the internal id of acceptedname `Plantae`, while in GBIF Backbone:

```{r example_Xanthophyta_GBIF_Backbone}
taxa_gbif %>% 
  filter(acceptedname == "Xanthophyta") %>%
  select(acceptedname) %>%
  gbif_species_name_match(name = "acceptedname")
```

The taxa with `matchType` not equal to `EXACT` or `EXACT_WITHOUT_AUTHOR` are matched again by using the combination of `acceptedname` and `scientificnameauthorship`. Matching without passing parameter kingdom can improve matching:

```{r match_without_kingdom}
taxa_gbif_without_kingdom <-
  taxa_gbif %>%
  filter(!matchType %in% c("EXACT_WITHOUT_AUTHOR", "EXACT")) %>%
  select(names(taxa)) %>%
  gbif_species_name_match(name = "name_for_gbif",
                          rank = "rank_for_gbif",
                          strict = TRUE)
```

Overview match:

```{r summarize_new_match_without_kingdom}
taxa_gbif_without_kingdom %>%
  group_by(matchType) %>%
  count()
```

As some of the matches might be wrong, we update `matchType` to `EXACT_WITHOUT_KINGDOM`, `FUZZY_WITHOUT_KINGDOM`:

```{r flag_matchType_without_kingdom}
taxa_gbif_without_kingdom <-
  taxa_gbif_without_kingdom %>%
  mutate(matchType = case_when(
    matchType == "EXACT" ~ "EXACT_WITHOUT_KINGDOM",
    matchType == "FUZZY" ~ "FUZZY_WITHOUT_KINGDOM",
    TRUE ~ matchType)
)
```

Include the results of this third match attempt to `taxa_gbif`:

```{r join_taxa_gbif_without_kingdom}
taxa_gbif <-
  taxa_gbif %>%
  anti_join(taxa_gbif_without_kingdom,
            by = "id") %>%
  bind_rows(taxa_gbif_without_kingdom) %>%
  arrange(id)
```

Overview  `matchType`:

```{r overview_matchType_3}
taxa_gbif %>%
  group_by(matchType) %>%
  count()
```

### Match by  `acceptedname` only and without kingdom

As fourth and final matching attempt, we try matching taxa without `authorship` and without passing kingdom as parameter. Please note that rank is always given to the match function.

The taxa with `matchType` not equal to `EXACT`, `EXACT_WITHOUT_AUTHOR` or `EXACT_WITHOUT_KINGDOM` are matched again by using `acceptedname` only. Matching without passing parameter kingdom can improve matching:

```{r match_without_kingdom_acceptedname_only}
taxa_gbif_acceptedname_without_kingdom <-
  taxa_gbif %>%
  filter(!matchType %in% c("EXACT_WITHOUT_KINGDOM", 
                           "EXACT_WITHOUT_AUTHOR", 
                           "EXACT")) %>%
  select(names(taxa)) %>%
  gbif_species_name_match(name = "acceptedname",
                          rank = "rank_for_gbif",
                          strict = TRUE)
```

Overview match:

```{r summarize_match_without_kingdom_acceptedname}
taxa_gbif_acceptedname_without_kingdom %>%
  group_by(matchType) %>%
  count()
```

As some of the matches might be wrong, we update `matchType` to `EXACT_WITHOUT_AUTHOR_WITHOUT_KINGDOM`, `FUZZY_WITHOUT_AUTHOR_WITHOUT_KINGDOM`:

```{r flag_matchType_without_author_and_kingdom}
taxa_gbif_acceptedname_without_kingdom <-
  taxa_gbif_acceptedname_without_kingdom %>%
  mutate(matchType = case_when(
    matchType == "EXACT" ~ "EXACT_WITHOUT_AUTHOR_WITHOUT_KINGDOM",
    matchType == "FUZZY" ~ "FUZZY_WITHOUT_AUTHOR_WITHOUT_KINGDOM",
    TRUE ~ matchType)
)
```

Include the results of this fourth match attempt to `taxa_gbif`:

```{r join_taxa_gbif_acceptedname_without_kingdom}
taxa_gbif <-
  taxa_gbif %>%
  anti_join(taxa_gbif_acceptedname_without_kingdom,
            by = "id") %>%
  bind_rows(taxa_gbif_acceptedname_without_kingdom) %>%
  arrange(id)
```

Overview  `matchType`:

```{r overview_matchType_4}
taxa_gbif %>%
  group_by(matchType) %>%
  count()
```

## Get number of occurrences per taxa

It is interesting to know how many occurrences are linked to the unmatched taxa. For example, taxa linked to many occurrences could be checked before other ones, thus prioritizing the work of the taxonomists. We retrieve this information by reading the occurrences from database.

### Connect to database

Connect to database:

```{r connect_to_db}
conn <- dbConnect(odbc(), 
                  driver = ibge_bim$driver,
                  server = ibge_bim$server,
                  database = ibge_bim$database,
                  port = ibge_bim$port,
                  uid = ibge_bim$uid,
                  pwd = ibge_bim$pwd,
                  encoding = "latin1"
)
```

### Get occurrences from table `occurence`

Table `occurence` contains occurrence data:

```{r get_occs}
occurrences <- 
  dbGetQuery(conn, "SELECT * FROM biodiv.occurence") %>%
  as_tibble()
```

Overview:

```{r overview_occs}
head(occurrences)
```

where `identifiablespeciesid` is the column corresponding to the column `id` of table `biodiv.taxon` where taxonomic data have been retrieved in previous pipeline  `get_taxa_from_db.Rmd`.

Number of occurrences:

```{r n_occs}
nrow(occurrences)
```

### Close connection

Close connection:

```{r close_connection_occs}
dbDisconnect(conn)
```

### Add number of occurrences to taxonomic data

We add a new column called `n_occs` containing the number of occurrences linked to each taxon:

```{r add_n_occs}
taxa_gbif <- 
  occurrences %>%
  group_by(identifiablespeciesid) %>%
  count() %>%
  ungroup() %>%
  rename(n_occs = n) %>%
  right_join(taxa_gbif,
             by = c("identifiablespeciesid" = "id")) %>%
  rename(id = identifiablespeciesid) %>%
  arrange(id)
```

Number of taxa with/without occurrences:

```{r n_taxa_with_without_occs}
taxa_gbif %>%
  group_by(!is.na(n_occs)) %>%
  count() %>%
  rename("has_occs" = "!is.na(n_occs)")
```

### Number of occurrences of unmatched taxa

In particular, for unmatched taxa (`matchType` not equal to `EXACT`):

```{r n_occs_unmatched_taxa}
taxa_gbif_unmatched <- 
  taxa_gbif %>%
  filter(matchType != "EXACT") %>%
  select(acceptedname,
         scientificnameauthorship,
         n_occs, 
         matchType, 
         confidence, 
         status, 
         usageKey,
         scientificName,
         canonicalName,
         rank,
         kingdom,
         phylum,
         class,
         order,
         family,
         genus,
         species,
         everything())
# preview
taxa_gbif_unmatched %>%
  head()
```

Number of unmatched taxa linked to at least one occurrence or none at all _and_ with or without parent ID:

```{r unmatched_taxa_count_n_occs}
taxa_gbif_unmatched %>%
  group_by(!is.na(parentid), !is.na(n_occs)) %>%
  count() %>%
  rename("has_parentid" = "!is.na(parentid)",
         "has_occs" = "!is.na(n_occs)"
)
```

Experts should focus first on taxa without parent ID, `has_parentid = FALSE`. Among these ones priority should be given to taxa with occurrences, `has_occs = TRUE`. To do so, we arrange the taxa by absence of parent ID and decreasing number of occurrences:

```{r taxa_gbif_unmatched_arrange_parentid_n_occs}
taxa_gbif_unmatched <- 
  taxa_gbif_unmatched %>%
  arrange(!is.na(parentid), n_occs)
```

Finally, it is also important to show the rank of the unmatched taxa:

```{r rank_of_unmatched_taxa}
taxa_gbif_unmatched %>%
  group_by(rank_for_gbif) %>%
  count()
```

# Save taxa

We save the taxa with the added information from GBIF Taxonomy Backbone:

```{r save_taxa_gbif}
write_tsv(taxa_gbif$,
          path = here::here("data", "interim", "taxa_gbif.tsv"),
          na = "")
```

We save the subset of the unmatched taxa in a separate file for verification.

```{r save_unmatched_taxa}
write_tsv(taxa_gbif_unmatched,
          path = here::here("data", "interim", "unmatched_taxa_gbif.tsv"),
          na = "")
```
