---
title: "Match taxa with GBIF Taxonomy Backbone"
author:
  - Damiano Oldoni
  - Lien Reyserhove
  - Peter Desmet
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    theme: yeti
    df_print: paged
knit: (function(input_file, encoding) { rmarkdown::render(input_file, encoding = encoding, output_file = paste0("../docs/",sub(".Rmd", ".html", basename(input_file))))})
---

# Setup

## Load libraries

```{r load_libs}
library(odbc)       # To work with database
library(tidyverse)  # To do data science
library(here)       # To work with paths
library(inborutils) # To match taxa (rgbif called in background)
```

## Load access informations

Retrieve access informations from configuration file:

```{r get_access_infos}
ibge_bim <- config::get("ibge_bim")
```

# Read taxa

Read taxa from `./data/interim/taxa.tsv`:

```{r read_taxa_from_tsv_file}
taxa <- read_tsv(here("data", "interim", "taxa.tsv"),
                 col_types = cols(
                   .default = col_character(),
                   id = col_double(),
                   parentid = col_double(),
                   media = col_logical(),
                   speciesbeparentid = col_double(),
                   bruenvi_created = col_date(format = "%Y-%m-%d"),
                   bruenvi_created = col_date(format = "%Y-%m-%d"),
                   kingdom_id = col_double()
                   )
)
```

# Match taxa to GBIF Taxonomy Backbone

## Match by `acceptedname` + `scientificnameauthorship`

We try to match by using `acceptedname` + `scientificnameauthorship`.
First, we prepare `taxa` for matching. In this step:

1. We create a new column, `name_for_gbif`, where we paste `acceptedname` and `scientificnameauthorship`, if present.
2. Recode the taxon ranks from `taxonranken` in a new column, `rank_for_gbif`, containing the correct GBIF terms

```{r prepare_taxa_for_matching_backbone}
taxa <-
  taxa %>%
  mutate(name_for_gbif = if_else(
    !is.na(scientificnameauthorship),
    paste(acceptedname, scientificnameauthorship),
    acceptedname
  )) %>%
  mutate(rank_for_gbif = recode(taxonranken,
    "forma" = "form",
    "subforma" = "subform",
    "informal group" = NA_character_
  ))
```

We match the names in `name_for_gbif` with GBIF Backbone. We also use the columns containing kingdom information, `bim_kingdom`, and rank, `rank_for_gbif`, and we require a strict match, `strict = TRUE` to avoid fuzzy match with higher classification. **Note: This step takes long**:

```{r get_name_gbif}
taxa_gbif <-
  taxa %>%
  gbif_species_name_match(name = "name_for_gbif",
                          kingdom = "bim_kingdom", 
                          rank = "rank_for_gbif",
                          strict = TRUE)
```

Some columns containing GBIF data have been added. Preview:

```{r overview}
taxa_gbif %>%
  head()
```

The column `matchType` informs us whether the match has been successful, `matchType` = `EXACT`, doubtful, `matchType` = `FUZZY`, or failed, `matchType` = `NONE`. The column  `confidence` is also informative. Number of taxa for each value of `matchType`:

```{r overview_n_match}
taxa_gbif %>%
  group_by(matchType) %>%
  count()
```

We create a new data.frame, `taxa_no_exact_match`, for taxa without exact match:

```{r taxa_no_exact_match}
taxa_no_exact_match <-
  taxa_gbif %>%
  filter(matchType != "EXACT") %>%
  arrange(id)
```

Preview (only relevant columns shown):

```{r not_matched_taxa}
taxa_no_exact_match %>%
  select(-c(speciesbeid, colid, vernacularnamefr, 
            vernacularnamenl, parentid, distributionstatuscode, 
            media, speciesbeparentid, bruenvi_created, bruenvi_author,
            bruenvi_modified, kingdom_id)) %>%
  head()
```

### Match by `acceptedname` only

Some of the taxa are not matched due to deviating author spellings, e.g.

```{r example_no_match_due_to_author_spelling_deviation}
taxa_no_exact_match %>%
  filter(name_for_gbif == "Neosartorya fischeri var. glabra (Fennell & Raper) Malloch & Cain")
```

while in GBIF Backbone:

```{r}
rgbif::name_backbone(name = "`Neosartorya fischeri var. glabra Fennell & Raper, 1973`") %>% as_tibble()
```

Matching without authors can improve matching:

```{r match_acceptedname_only}
taxa_gbif_acceptedname <-
  taxa_no_exact_match %>%
  select(names(taxa), -c(name_for_gbif)) %>%
  gbif_species_name_match(name = "acceptedname",
                          kingdom = "bim_kingdom", 
                          rank = "rank_for_gbif",
                          strict = TRUE)
```

Overview match:

```{r summarize_new_match}
taxa_gbif_acceptedname %>%
  group_by(matchType) %>%
  count()
```

As some of the matches might be wrong, we update `matchType` to `EXACT_WITHOUT_AUTHOR`, `FUZZY_WITHOUT_AUTHOR`:

```{r flag_matchType}
taxa_gbif_acceptedname <-
  taxa_gbif_acceptedname %>%
  mutate(matchType = case_when(
    matchType == "EXACT" ~ "EXACT_WITHOUT_AUTHOR",
    matchType == "FUZZY" ~ "FUZZY_WITHOUT_AUTHOR",
    TRUE ~ matchType)
)
```

Include the results of this second match attempt to `taxa_gbif`:

```{r join_taxa_gbif_acceptedname}
taxa_gbif <-
  taxa_gbif %>%
  anti_join(taxa_gbif_acceptedname,
            by = "id") %>%
  bind_rows(taxa_gbif_acceptedname) %>%
  arrange(id)
```

Overview:

```{r }
taxa_gbif %>%
  group_by(matchType) %>%
  count()
```

## Get number of occurrences per taxa

It is interesting to know how many occurrences are linked to the unmatched taxa. For example, taxa linked to many occurrences could be checked before other ones, thus prioritizing the work of the taxonomists. We retrieve this information by reading the occurrences from database.

### Connect to database

Connect to database:

```{r connect_to_db}
conn <- dbConnect(odbc(), 
                  driver = ibge_bim$driver,
                  server = ibge_bim$server,
                  database = ibge_bim$database,
                  port = ibge_bim$port,
                  uid = ibge_bim$uid,
                  pwd = ibge_bim$pwd,
                  encoding = "latin1"
)
```

### Get occurrences from table `occurence`

Table `occurence` contains occurrence data:

```{r get_occs}
occurrences <- 
  dbGetQuery(conn, "SELECT * FROM biodiv.occurence") %>%
  as_tibble()
```

Overview:

```{r overview_occs}
head(occurrences)
```

where `identifiablespeciesid` is the column corresponding to the column `id` of table `biodiv.taxon` where taxonomic data have been retrieved in previous pipeline  `get_taxa_from_db.Rmd`.

Number of occurrences:

```{r n_occs}
nrow(occurrences)
```

### Close connection

Close connection:

```{r close_connection_occs}
dbDisconnect(conn)
```

### Add number of occurrences to taxonomic data

We add a new column called `n_occs` containing the number of occurrences linked to each taxon:

```{r add_n_occs}
taxa_gbif <- 
  occurrences %>%
  group_by(identifiablespeciesid) %>%
  count() %>%
  ungroup() %>%
  rename(n_occs = n) %>%
  right_join(taxa_gbif,
             by = c("identifiablespeciesid" = "id")) %>%
  rename(id = identifiablespeciesid) %>%
  arrange(id)
```

Number of taxa with/without occurrences:

```{r n_taxa_with_without_occs}
taxa_gbif %>%
  group_by(!is.na(n_occs)) %>%
  count() %>%
  rename("has_occs" = "!is.na(n_occs)")
```

### Number of occurrences of unmatched taxa

In particular, for unmatched taxa (`matchType` not equal to `EXACT`):

```{r n_occs_unmatched_taxa}
taxa_gbif_unmatched <- 
  taxa_gbif %>%
  filter(matchType != "EXACT") %>%
  select(acceptedname,
         scientificnameauthorship,
         n_occs, 
         matchType, 
         confidence, 
         status, 
         everything()) %>%
  arrange(desc(n_occs))
taxa_gbif_unmatched
```

Number of unmatched taxa linked to at least one occurrence or not at all:

```{r unmatched_taxa_count_n_occs}
taxa_gbif_unmatched %>%
  group_by(!is.na(n_occs)) %>%
  count() %>%
  rename("has_occs" = "!is.na(n_occs)")
```

# Save taxa

We save the taxa with the added information from GBIF Taxonomy Backbone:

```{r save_taxa_gbif}
write_tsv(taxa_gbif,
          path = here::here("data", "interim", "taxa_gbif.tsv"))
```

We save the subset of the unmatched taxa in a separate file as well for ease consultation. The unmatched taxa are also arrange by decreasing number of occurrences:

```{r save_unmatched_taxa}
write_tsv(taxa_gbif_unmatched,
          path = here::here("data", "interim", "unmatched_taxa_gbif.tsv"))
```

