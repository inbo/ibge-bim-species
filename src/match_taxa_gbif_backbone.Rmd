---
title: "Match taxa with GBIF Taxonomy Backbone"
author:
  - Damiano Oldoni
  - Lien Reyserhove
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    theme: yeti
    df_print: paged
knit: (function(input_file, encoding) { rmarkdown::render(input_file, encoding = encoding, output_file = paste0("../docs/",sub(".Rmd", ".html", basename(input_file))))})
---

# Setup

## Load libraries

```{r load_libs}
library(tidyverse)  # To do data science
library(here)       # To work with paths
library(inborutils) # To match taxa (rgbif called in background)
```

# Read taxa

Read taxa from `./data/interim/taxa.tsv`:

```{r read_taxa_from_tsv_file}
taxa <- read_tsv(here("data", "interim", "taxa.tsv"),
                 col_types = cols(
                   .default = col_character(),
                   id = col_double(),
                   parentid = col_double(),
                   media = col_logical(),
                   speciesbeparentid = col_double(),
                   bruenvi_created = col_date(format = "%Y-%m-%d"),
                   bruenvi_created = col_date(format = "%Y-%m-%d"),
                   kingdom_id = col_double()
                   )
)
```

Read anomalous taxa, see [issue #7](https://github.com/inbo/ibge-bim-species/issues/7). They will be temporarily removed before searching.

```{r read_anomalous_taxa}
anomalous_taxa <- read_tsv(
  here("data", "interim", "anomalous_taxa.tsv"),
  col_types = cols(
                   .default = col_character(),
                   id = col_double(),
                   parentid = col_double(),
                   media = col_logical(),
                   speciesbeparentid = col_double(),
                   bruenvi_created = col_date(format = "%Y-%m-%d"),
                   bruenvi_created = col_date(format = "%Y-%m-%d"),
                   kingdom_id = col_double())
)
```

Remove anomalous taxa:

```{r remove_suspected_taxa}
taxa <- 
  taxa %>%
  anti_join(anomalous_taxa,
            by = c("id", "speciesbeid", 
                   "colid", "acceptedname", 
                   "vernacularnamefr", 
                   "vernacularnamenl", "scientificnameauthorship", 
                   "parentid", "distributionstatuscode", 
                   "taxonranken", "media", 
                   "taxonomicstatusen", "speciesbeparentid", 
                   "bruenvi_created", "bruenvi_modified", 
                   "bruenvi_author", "kingdom_id", "kingdom"))
```

# Match taxa to GBIF Taxonomy Backbone

## Match by `acceptedname` + `scientificnameauthorship`

We try to match by using `acceptedname` + `scientificnameauthorship`.
First, we prepare `taxa` for matching. In this step:

1. We create a new column, `name_for_gbif`, where we paste `acceptedname` and `scientificnameauthorship`, if present.
2. Recode the taxon ranks from `taxonranken` in a new column, `rank_for_gbif`, containing the correct GBIF terms

```{r prepare_taxa_for_matching_backbone}
taxa <-
  taxa %>%
  mutate(name_for_gbif = if_else(
    !is.na(scientificnameauthorship),
    paste(acceptedname, scientificnameauthorship),
    acceptedname
  )) %>%
  mutate(rank_for_gbif = recode(taxonranken,
    "forma" = "form",
    "subforma" = "subform",
    "informal group" = NA_character_
  ))
```

We match the names in `name` with GBIF Backbone. We also use the columns containing kingdom information, `bim_kingdom`, and rank, `rank_for_gbif`, and we require a strict match, `strict = TRUE` to avoid fuzzy match with higher classification. This step can take long:

```{r get_name_gbif}
taxa_gbif <-
  taxa %>%
  gbif_species_name_match(name = "name",
                          kingdom = "bim_kingdom", 
                          rank = "rank_for_gbif",
                          strict = TRUE)
```

Some columns containing GBIF data have been added. Preview:

```{r overview}
taxa_gbif %>%
  head()
```

The column `matchType` informs us whether the match has been successful, `EXACT`, doubtful, `FUZZY`, or failed, `NONE`. The column  `confidence` is also informative. Number of taxa for each value of  `matchType`:

```{r overview_n_match}
taxa_gbif %>%
  group_by(matchType) %>%
  count()
```


```{r not_matched_taxa}
taxa_gbif %>%
  filter(matchType != "EXACT") %>%
  select(acceptedname, scientificnameauthorship, name, ...)
```


```{r}
occurrences_gbif_info %>%
  filter(is.na(parentid)) %>%
  distinct(identifiablespeciesid) %>%
  count()
```

```{r }
occurrences_gbif_info %>%
  filter(matchType == "NONE") %>%
  distinct(identifiablespeciesid) %>%
  left_join(taxa, by = c("identifiablespeciesid" = "id"))
```

```{r}
taxa_gbif %>%
  filter(matchType == "NONE") %>%
  write_tsv("taxa_no_match_GBIF_backbone", na = "")
getwd()
```


```{r} 
taxa_gbif %>%
  filter(is.na(parentid)) %>%
  group_by(matchType) %>%
  count()
```

